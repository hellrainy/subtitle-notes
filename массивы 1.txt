Привет мы продолжаем курс по JavaScript

для начинающих на предыдущем уроке мы

начали изучать тему методов у примитивов

разобрали методы чисел ознакомились с

объектом мас и узнали о том как числа

округлять и парсить из строк в этом

уроке изучим полезные свойства и методы

строк напоминаю у нас в телеграме есть

чат по фронтенду где ты можешь задать

вопрос по веб-разработке и получить

ответ ссылка на Telegram чат в описании

под видео Присоединяйся если тебе это

интересно ну а мы начинаем у строк как и

у чисел есть несколько подкапотный

свойств и методов к которым можно

получить доступ обратившись к строке как

К объекту первое важное свойство leng

позволяет получить длину строки в

формате числа строка с текстом Александр

имеет длину девять символов пустая

строка - ноль а строка с одним пробелом

имеет длину один акцентируя внимание на

том что leng - это обычное свойство

содержащее в значении число а не метод

который нужно вызывать с круглыми

скобками в конце то есть просто

прописывается строка или сущ вые в

строку точка и L далее рассмотрим

возможность получить конкретный символ

из строки по его индексу допустим если

нам нужно получить первый символ строки

находящейся в переменной name то можно

написать name пару квадратных скобок и

внутри указать индекс но мы получили в

консоли первый символ строки букву А

если нужен доступ к первому символу

используем индекс но а если нужен доступ

ко второму используем индекс 1 и так

далее то есть для получения энного

символа из строки нужно обращаться по

индексу N - 1 отрицательный индекс быть

не может в консоли мы увидим результат

такого выражения как undefined А чтобы

получить к примеру Последний символ этой

строки нам не обязательно указывать name

и в квадратных скобках число восем в

квадратных скобках можно указать

выражение name leng - 1 name L вернёт

длину строки число де а затем из этого

числа вычитается ени и получается 8 в

консоле мы видим корректное значение

Последний символ строки с текстом

Александр - это буква R очень важно

запомнить что в жава скрипте индексы

ведут свой отчёт с нуля к индексам Мы

ещё вернёмся в теме про массивы А пока

двигаемся дальше и рассмотрим ещё один

способ получения доступа к конкретному

символу строки метод Add применяется к

строке как К объекту То есть через точку

и в аргументах принимает число номер

позиции наподобие индекса Однако есть

указать отрицательные значения если

указать 0 то получим первый символ из

строки 1 получим второй а если указать

допустим -1 то получим первый символ с

конца строки То есть фактически

Последний символ строки Add -2 позволяет

же получить второй символ с конца чтобы

получить первый и второй символ с конца

строки через синтаксис квадратных скобок

пришлось бы писать вот подобные вот

инструкции как мне кажется метод

ми1 -2 в аргументе на фоне синтаксиса с

квадратными скобками и L гораздо

понятней напоследок отмечу что при

обращение к строкам через квадратные

скобки или же через метод Add позволяет

лишь получить символ из строки по

индексу но изменить его таким образом не

получится инструкция с квадратными

скобками и присвоением новой буквы не

будет иметь эффекта А вызов метода и

попытка дальнейшего присвоения значения

вовсе вызовет ошибку в коде далее методы

изменения регистра символов строки чтобы

получить строку с текстом в Нижнем

регистре в JavaScript применяется метод

to lower Case А чтобы получить строку с

буквами в верхнем регистре применяется

метод to uper Case далее рассмотрим

метод избавления строки от пробелов в

начале и в конце есть переменная message

в значении записана строка с текстом

Привет Но в начале и в конце добавлены

пробельные символы длина такой строки

будет включать в себя учёт этих самых

пробелов в консоли Мы видим что такая

строка имеет длину 12 символов в

джаваскрипт есть метод строк ТМ который

обрезает пробелы в начале и в конце

строки Таким образом мы получим строку в

которой убраны лишние пробелы с обеих

сторон Если же пробелы находятся не в

начале и не в конце то обреза они уже не

будут помимо метода ТМ для обрезки

пробелов с обеих концов строки есть

методы для точечного отсечения пробелов

в начале или в конце строки Trim Start и

triam end далее рассмотрим полезный

метод Index of Он позволяет получить

индекс первого символа подстроки в

строке здесь мы применяем метод Index of

к переменной mess в значение которой

указана строка с таким текстом в

аргументы метода индексов прописываем

строку которую пытаемся найти в mess

если такая строка будет обнаружена то мы

получим число индекс от нуля и более в

данном случае индекс 14 именно с этой

позиции в строке mess начинается эта

подстрока искать можно в том числе даже

отдельный символ такое выражение вернёт

индекс ноль так как буква P в этой

строке стоит в самом начале

Следовательно имеет нулевой индекс Если

же Мы попытаемся найти подстроку которой

точно нет в message в результате получим

индекс -1 а это значит что такой

подстроки в строке message нет Обычно

такие проверки на наличие подстроки в

строке я делают таким вот образом То

есть если это выражение вернёт -1 то

результат сравнения будет false и это

будет означать что подстрока не найдена

во всех иных случаях если метод индексов

вернёт корректный индекс результат этой

проверки будет True то есть подстрока в

строке будет найдена Однако в

современном жава скрипте есть более

удобный метод для решения той же задачи

метод includes он сразу вернёт True или

false значение в зависимости от того

есть ли указанная подстрока в строке

mess или нет У строк есть ещё множество

полезных методов например starts with и

ends with которые проверяют начинается и

оканчивается ли строка на указанное

значение каждому из последних четырёх

рассмотренных методов можно передать

второй аргумент индекс номер позиции

символа строки С которой будет

происходить поиск вхождения допустим

здесь мы через Икс of ищем индекс начала

подстроки с текстом и в

начиная с четвёртой позиции буква P в

этой строке начинается с нулевого

индекса то есть с позиции ноль буква R с

индекса 1 и с индекса 2 V с индекса 3 и

е с индекса 4 получается что мы ищем в

этой строке под строку If начиная с этой

позиции там где сейчас у меня горит

курсор и не находим её потому что метод

индек вернул значение -1 с incl та же

ситуация попытка найти под строку с

четвёртой позиции провалилось и

вернулось значение false в starts Vis Я

указал вторым аргументом позицию Ноль

это как бы дефолтный индекс с которого

начинается поиск и очевидно что строка с

текстом Привет начинается с символов P и

R поэтому метод Start swi вернул True а

вот второй аргумент в end swi работает

немножко иначе здесь мы указываем номер

позиции которая будет считаться концом

строки мы указали число три а это символ

V в этой строке и получается проверка

заканчивается ли строка с текстом priv

на подстроку с текстом е результат этой

проверки значение false А вот если же мы

укажем вторым аргументом в n If

выражение message то L то результат

такой проверки будет уже True так как мы

буквально использовали длину строки mess

в качестве номера позиции которая

является окончанием строки если второй

аргумент в If не указать под капотом по

умолчанию будет использоваться как раз

длина строки чтобы проверка окончания

строки была строго с последнего символа

далее рассмотрим способы обрезки стки и

ес перефразировать способы получить

подстроку из строки первый метод subst

Принимает два аргумента начальный и

конечный индекс подстроки которую

вырезаем результатом возвращает

подстроку которая в исходной строке

находится начиная с позиции но и

заканчивается на позиции 4 по поводу

второго аргумента стоит сделать

небольшое пояснение следите за курсором

нулевой индекс начинается здесь первый

тут второй Тут третий тут а четвёртый

тут то есть четвёртый индекс между

строчной буквой A и заглавной буквой S

получается что указав в аргументы метода

substring индексы 0 и 4 мы явно указали

что хотим получить подстроку от начала

строки до вот этого вот места где сейчас

мелькает курсор вме этот substring можно

не передавать второй аргумент вовсе в

таком случае в качестве финального

индекса по умолчанию будет

использоваться индекс последнего символа

строки и на выходе мы получаем вот такую

вот

подстроку стоит упомянуть что у метода

substring есть не очевидная особенность

в аргументы методу мы передаём числа

начало и конец индексы которые

ограничивают вырезает буквально от и до

и вот Казалось бы начальный индекс

должен быть строго меньше чем конечный

иначе ведь и быть не может но этот метод

позволяет передавать индексы в любом

порядке и даже первый может быть больше

чем второй В таком случае для выяснения

отрезка начала и конца вырезает строки

JavaScript просто поменяет эти значения

местами Я не представляю где может

пригодиться подобная механика но такой

код лично меня немножко запутывает и

вводит в заблуждение поэтому смотрим ещё

один метод который выполняет подобную

задачу метод сй результат в консоли

будет абсолютно такой же как и substring

но метод сй в отличие от substring не

позволяет менять индексы местами Так что

начальный будет больше чем конечный

такой код просто вернёт пустую строку Я

считаю что это поведение всё же логичнее

когда JavaScript за тебя не меняет

местами аргументы в попытках исправить

вероятную ошибку в коде у сй помимо этой

особенности есть ещё одна фишка в

аргументах сй можно передать

отрицательный индекс допустим если

прописать единственный аргумент как

отрицательное число например -6 то метод

отработает Так что обре может строку с

шестого с конца символа и до конца

строки Ну или другими словами мы

получили последние шесть символов строки

с её конца если бы мы использовали с

таким же аргументом не метод сй а метод

substring результатом была бы искомая

строка то есть ничего бы не сработало

так как substring не обрабатывает

отрицательные индексы в аргументах

вернёмся к сй если передать два

отрицательных аргумента допустим -6 и -3

то мы получим строку которая начинается

в исходной строке на шестом индексе с

конца и заканчивается на третьем индексе

с конца при том Обратите внимание что

второй аргумент -3 больше чем первый -6

если бы они были в другом порядке то

метод вернул бы просто пустую

строку идём дальше следующий метод для

работы со строками РЕТ название говорит

само за себя повторяет строку указанное

количество раз и возвращает результатом

новую строку далее рассмотрим методы для

замены подстроки в строке первый метод -

replace Принимает два аргумента что

меняем И на что меняем например Здесь в

строке message заменили слово backend на

frontend и всё это выражение смотрим по

консоли вернуло результатом такую строку

если в строке будет несколько вхождений

под строки которую мы хотим заменить то

в результате мы получим строку где

произошла замена лишь первого вхождения

этой самой подстроки второе слово

backend осталось без изменений так

работает метод replace заменяет первую

обнаруженную подстроку на то что мы

укажем если же мы хотим заменить все

вхождения то мы можем воспользоваться

методом replace All в таком случае мы

получим сообщения где все вхождения под

строки backend а не только первая были

заменены на frontend оба метода replace

и All первым аргументом могут принимать

не просто строки а целые регулярные

выражения это отдельная и довольно

непростая тема которую в рамках курса мы

не будем особо разбирать но приведу

парочку базовых примеров чтобы заменить

все вхождения строки не обязательно

использовать метод replace All

достаточно в методе replace первым

аргументом написать вот такое вот

выражение с флагом G в конце тело

регулярного выражения в джаваскрипт

пишется между символами слыша а в конце

могут находиться так называемые флаги

спецсимволы обычно буквы отвечающие за

некоторые правила работы выражения вот

благодаря флагу G регулярка будет искать

все совпадения а не только первое А если

нам нужно чтобы регулярное выражение

искало вхождение без учёта регистра то в

конце регулярного выражения можно

добавить флаг I вот прямо так слитно с

уже имеющимся флагом G теперь Каким бы

ни было в искомой строке слово backend в

верхнем или Нижнем регистре или даже в

перемешку все эти строки найдутся нашим

регулярным выражением и замениться на

слово frontend и последний пример с

регулярным выражением нужно заменить все

цифры в этой строке на символ решётки

чтобы найти все числовые символы в

строке можно воспользоваться в

регулярном выражении специальной

инструкцией

D и не забываем про флаг G в конце и вот

мы получили строку где все цифры

заменены на символ решётки и рассмотрим

ещё один метод для работы со строками

Split метод Сплит позволяет разбить

строку на массив по указа разделителю

который передаётся в аргументе из

текущей строки с текстом Привет запятая

мир мы получили массив из двух элементов

слово привет с большой буквы и мир с

восклицательным знаком в конце про

массивы мы будем основательно говорить в

следующем уроке но не упомянуть этот

метод для работы со строками я не мог в

этом примере Мы в качестве разделителя

указали строку в которой указан символ

запятой и пробел Если же мы укажем в

качестве разделителя просто пустую

строку то в консоли мы можем увидеть

массив где Каждый элемент - это ровно

один символ из строки в том числе здесь

есть знаки припинания и символ пробела

задача разбить строку на массив по

определённому разделителю очень часто

встречается во фронтенде и различных

алгоритмических Задачка в частности

метод Сплит позволяет получить строку в

виде массива с которым можно Очень

удобно работать в дальнейшем Но после

того как со строкой поработали в формате

массива её можно без проблем перегнать

из массива обратно в строку об этом мы

обязательно поговорим в следующем уроке

напоследок разберём важную механику все

методы которые мы сегодня разобрали не

мутируют исходную строку Что это значит

есть вот такой вот код переменная

message содержит в значении строку с

текстом Привет притом в строке есть

пробелы в начале и в конце далее выводим

это сообщение в консоль после идёт

несколько последовательных инструкций

для переменной message вызывается

несколько методов метод м обрезает

строку от пробелов в начале и в конце

метод to uper Cas преобразует строку в

Верхний регистр метод сй обрезает строку

с нулевого до четвёртого индекса если мы

выведем влоги message ещё раз то мы

увидим всю ту же исходную строку Почему

так получилось Мы же вызывали методы

которые явно Казалось бы изменяют строку

строка сначала должна была избавиться от

пробелов в начале и в конце затем

превратиться в Верхний регистр затем

обреза с нулевого поче индекс но как

будто бы этого не произошло на самом

деле Ошибки здесь никакой нет все эти

методы строк не мутируют исходную строку

то есть они её не изменяют каждое из

этих выражений вернула вникуда результат

с изменённой строкой но исходная

сущность не поменялась если мы поменяем

const mess на Let mess то есть сделаем

переменную mess не константной затем

Каждую из этих инструкций будем

записывать в качестве обновлённого

значения переменной mess то в таком ВМ

случае мы каждый раз переопределять

значение переменной mess тем значением

которое возвращалось выражением справа

от оператора присваивания и в конце

концов сообщение после всех

трансформаций стало именно вот таким

Кстати этот же код можно переписать с

помощью синтаксиса ченга вот таким вот

образом Ну и можно дополнительно

отформатировать вот так вот чтобы лучше

читалось кода стало меньше и он стал

выглядеть чище при работе со строками

крайне важно понимать как работают

методы и что они Исход строку не

изменяют что выражение с применением

метода лишь вернёт новый результат если

мы его нигде адекватно не используем не

Запишем в переменную то и смысла от

отработавшего метода толком не будет и в

конце сегодняшнего урока рассмотрим одну

задачку на методы строк очень часто во

фронтенде нам приходится проверять ввёл

ли пользователь данные в поле ввода

корректно в рамках курса Мы ещё не

проходили специальные JavaScript

конструкции в браузере поиск элементов

на странице обработка событий и так

далее

поэтому мы будем проверять данные

которые пользователь сайта вводит в

окошке которое вызвано в коде через уже

известную нам функцию prompt мы ожидаем

что пользователь должен ввести своё имя

и должен вести его корректно А если есть

ошибка во введённых данных мы должны

вывести для пользователя текст с

описанием ошибки введённое пользователем

значение сначала записывается в

переменную value а затем Давайте Запишем

в Новую переменную с названием Clear

value результат обработки строки методом

м так мы обре можем ненужные пробелы в

начале и в конце строки далее сделаем

проверку что если длина введённого

значения очищенного от пробелов равна

нулю то выведем

Alert с текстом

ошибки имя не может быть

пустым Теперь попробуем ввести в окошко

просто несколько пробелов и нажмём Enter

мы ожидаем получить соответствующую

ошибку и мы её получили Теперь давайте в

нашу проверку добавим фильтрацию на

Запретные слова представим что в

качестве имени нельзя использовать слово

админ во всех его вариациях регистра

чтобы проверить есть ли в введённой

строке запретное значение можно

использовать метод includes If Clear

value includes

Admin

Alert ошибка Вы не можете занять это имя

Обратите внимание проверяем мы уже не

просто value а Clear так как мы

обрабатываем уже чистое значение без

лишних пробелов в начале и в конце если

сейчас мы введём во всплывающем окошке

строку которая содержит слово админ то

получим ошибку но Что будет если ввести

в хитром смешанном регистре допустим вот

таким вот

образом ошибки никакой уже нет так как

метод includes не учитывает вхождение

под строки с другим регистром чтобы это

доработать мы можем дополнительно В

переменной Clear value цепочкой

использовать метод to lower

Case чтобы вся строка которую ввёл

пользователь далее уже проверялась в

Нижнем регистре теперь проверка Clear

value includes Admin обработает даже

если пользователь hre и вводит слово

Admin в таком вот смешанном регистре и

мы получили соответствующую ошибку

подобных проверок с использованием

методов строк можно добавить Сколь

угодно много Но обычно серьёзная

валидация делается через регулярные

выражения чтобы можно было проверить

какие-то Запретные слова или к примеру

формат соответствия введённого значения

определённому шаблону как это обычно

бывает при вводе в поле допустим номера

телефона в этом уроке мы узнали о

свойстве строк lengths для получения

длины строки научились получать

конкретный символ из строки по его

индексу а также разобрали ряд полезных

методов для изменения регистра обрезки

лишних пробелов для проверки наличия в

строке определённой подстроки методы

проверки начала и окончания строки на

определённое значение ещё мы разобрались

в том как строки обрезать повторять

заменять определённые подстроки другими

значениями а также научились разбивать

строку на массив в следующем уроке мы

как раз будем разбираться с массивами

супер важной и полезной структурой

данных в JavaScript подписывайтесь на

канал чтобы не пропустить новые

материалы Спасибо за просмотр и до

встречи в следующих видео


