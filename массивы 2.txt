Привет мы продолжаем курс по JavaScript

для начинающих на предыдущем уроке мы

начали изучать массивы И помимо основ

синтаксиса рассмотрели базовые методы

добавления и удаления элементов в этом

уроке продолжаем разбираться с массивами

и изучаем ещё больше полезных методов

которые точно пригодятся вам на практике

напоминаю у нас в телеграме есть чат по

фронтенду где ты можешь задать вопрос по

веб-разработке и получить ответ ссылка

на Telegram чат в описании под видео

Присоединяйся если тебе это интересно ну

а мы начинаем Прежде чем продолжить

изучать методы массивов затронем на

минутку полезней ую механику

деструктуризация значений из массива

допустим Если есть массив Data с такими

значениями то чтобы получить отдельными

переменными каждый из этих элементов

массива можно прописать

следующее но так делали раньше сейчас

как и при работе с объектами можно

использовать синтаксис деструктуризация

Александр а в H значение второго число

28 единственное отличие механики

деструктуризация при работе с массивами

порядок крайне важен если из объектов мы

можем получать свойства в виде отдельных

переменных в абсолютно любом порядке то

с массивами так не получится если name и

H поменять

местами то получится Неразбериха в H

будет значение Александр а в name число

28 поэтому будьте внимательны когда

применяете этот синтаксис при работе с с

массивами переходим к основной теме

сегодняшнего урока частая Задачка при

работе с массивами просто их перебрать в

прошлом уроке мы использовали для этой

цели классический цикл for в круглых

скобках задаём правила выполнения

начинаем с счётчика цикла ноль и

продолжаем выполнение цикла до тех пор

пока счётчик цикла меньше чем длина

перебираемые Затем в теле цикла фор мы

можем получить доступ к определённому

элементу массива по его индексу А в

качестве индекса используем переменную I

которая отвечает за счётчик цикла такой

способ имеет место быть но в современном

жава скрипте есть встроенные методы для

перебора массивов которые зачастую

удобнее чем классические циклы чтобы

просто перебрать элементы массива можно

воспользоваться методом for each пишется

следующим образом Обращаемся к

переменной содержащей в значении массив

или же Обращаемся напрямую к массиву и

через точку вызываем метод for each в

круглых скобках for принимает один

аргумент функцию так называемый callback

я использу

стрелочной функции потому что он короче

но можно использовать и классический

function

declaration верну стрелочный запись Итак

эта функция будет выполняться на каждой

итерации цикла который переберёмся

эти сущности прописываются в круглых

скобках функции колка в строгом порядке

но называть их можно как угодно Я дал им

максимально классические имена при

исполнении этой части кода JavaScript

будет последовательно перебирать массив

letters и на каждой итерации цикла в

первом параметре колка в сущности

которую сейчас мы назвали Element будет

храниться текущий элемент массива если

на каждой итерации цикла будем выводить

в консоль эту

сущность то в консоли увидим строчки

друг за другом с выводом каждого из

элементов массива letters так как мы

перебираем letters то есть бук то

логичнее будет переименовать сущность

Element в Letter так как в этой сущности

будет храниться буква такой код стал

восприниматься чуточку лучше переходим к

следующему параметру индекс его Также

можно назвать как угодно Но обычно пишут

либо индекс либо кратко просто I

формально Это счётчик цикла текущий

индекс перебираемые

мы можем вывести такое сообщение в

консоль и увидим что в индекс всякий раз

находится число от нуля до четырёх ноль

индекс начального элемента 4ре индекс

последнего Ну и остаётся разобраться с

сущностью array это у нас просто ссылка

на сам перебираемые

массив каждый из этих трёх сущностей

опционально мы не обязаны использовать

их все зачастую на практике используется

лишь первая сущность то есть конкретный

элемент массива соответствующей итерации

цикла Итак с помощью метода for можно

перебрать элементы массива и выполнить

какую-то собственную логику Но помимо

обычного циклического перебора у

массивов есть и другие полезные методы

иногда нам может потребоваться найти

индекс элемента в массиве для этой цели

в джаваскрипт есть метод Index of

Допустим мы хотим получить индекс вот

этого вот элемента числа

444 для этого достаточно обратиться к

prices вызвать у него метод ИК of и в

аргументы передать значение которое

JavaScript будет искать в prices и если

найдёт вернёт е индекс в консоли мы

видим результат 2 именно такой индекс у

элемента 444 в массиве prices Если же Мы

попытаемся найти индекс элемента

которого наверняка нет в исходном

массиве В результате мы получим значение

-1 Ну а так как индекс в целом не может

быть отрицательным то с помощью такого

способа можно проверять Существует ли

определённый элемент в массиве или нет

Если сравнить результат выполнения

индексов с минус единицей Это не совсем

Стандарт на применение метода для

проверки наличия элементов в массиве

есть и другие методы о которых поговорим

чуть позднее а пока продолжим работу с

методом Index of в метод indexof можно

дополнительно передать второй аргумент

индекс с которого будет происходить

поиск в массиве Допустим мы хотим найти

индекс числа 444 но начиная например вот

с этой позиции этот элемент число 500

имеет индекс 3 значит и запишем это

число вторым аргументом в икс of в

консоли мы видим уже иной результат

число 4 именно этот индекс у второго

числа 444 в массиве prices в дополнении

к методу ИК of в джаваскрипт есть метод

Last Index of делает всё тоже самое что

и оригинальный метод но производит поиск

с конца То есть как бы справа налево

иногда Нам действительно будет

оптимальнее искать в массиве с конца В

таких случаях нам как раз может помочь

Last Index of как и с индек of метод

Last индексов вторым аргументом может

принимать индекс элемента с которого

будет происходить поиск Допустим если

указать число 3 то поиск числа 444 в

массиве prices будет происходить от

этого элемента числа 500 в левую сторону

и в консоли мы видим уже другой

результат Число два именно такой индекс

у элемента 444 который мы здесь нашли А

что будет если массив в котором мы хотим

найти определённый элемент и его индекс

будет содержать элементы с не

примитивным типом данных например

объекты в таком случае использовать

методы Index of и Last Index of уже

будет нельзя Ну нам конечно ничто не

помешает их использовать но толку будет

мало такой код всегда вернёт минус о А

почему так получается Мы ведь указали

точно такой же объект с точно такими же

свойствами и значениями как у вот этого

вот объекта на самом деле секрета здесь

никакого нет вспоминаем что объект - Это

ссылочный тип данных и просто так

JavaScript проверить корректно

эквивалентность объектов не может чтобы

решить задачку по поиску индекса этого

объекта в массиве users можно применить

другой метод find

Index у нас в аргументе есть функция

callback с тремя параметрами Element

Index и array тут всё точно так же как в

callback функции внутри метода for с

этой связкой мы будем и дальше часто

сталкиваться в методах массивов Так что

привыкайте так вот как работает метод

find Index Он позволяет вручную

перебрать каждый из элементов массива и

на каждой итерации цикла проверить

определённое условия допустим If Element

name равно

Василий

True если на какой-то итерации цикла это

условие будет истина то мы можем

выполнить инструкцию Return True в таком

случае функция find Index будет считать

что искомый элемент в массиве найден

find то есть всё вот это выражение Верт

инкс соответствующего найденного

элемента сущности ик и arr как и в

случае с for опциона мы можем их не

использовать Давайте их про удалим Ну а

сущность Element ше будет обозвать про

Как так будет сразу понят что р - это

ское всего Като объ с данными о

пользователя а не абстрактный элет также

всю эту запись можно сократи до

следующей

то есть мы сразу в стрелочной функции

написанной в одну строку возвращаем

результат выполнения этого выражения и

если он будет True то мы получим то что

хотели индекс элемента из массива на

самом деле можно пойти ещё дальше и

сделать дополнительную деструктуризация

свойства name из объекта User Ну то есть

мы просто вытаскиваем свойство name и

сразу сравниваем его со строкой Василий

нам такая сокра запись объекта с

деструктуризация может немножко ухудшать

читаемость кода поэтому Давайте вернём

код на шаг назад итак по итогу мы нашли

индекс элемента индекс объекта в массиве

users у которого в свойстве name

значение Василий Если же мы хотим

оптимизировать поиск и выполнять его с

конца то есть справа налево то можно

воспользоваться методом find Last

Index довольно часто Нам нужно просто

проверить наличие элементо в массиве для

этого в принципе можно использовать все

методы которые были перечислены в этом

уроке ранее в частности Index of Last

Index of find Index и find Last Index

если полученный индекс не равен единице

то можно смело утверждать что элемент в

массиве присутствует но в жава скрипте

для проверки наличия элементов в массиве

есть способ удобнее метод includes

используется он очень просто аргументом

принимает элемент который мы будем

искать в иском массиве и если элемент в

массиве есть метод incl Верт результат

как Ну а в ином случае как и с

предыдущими методами можно передать

вторым аргументам индекс с которого

будет происходить поиск если передать

допустим число 4 то диапазон поиска

сократится до вот такого вот то есть

поиск будет от этого до этого элемента и

результат выполнения поиска показал fse

так как начиная с четвёртого индекса в

Масси элемент число 500 уже не найден

как и с предыдущими методами есть

проблема мы не можем просто так взять и

Проверить наличие более сложных структур

например найти объект такое выражение

вернёт всегда fse так как объекты

повторюсь сравниваются По ссылкам здесь

и здесь совершенно разные объекты хоть и

Казалось бы с одинаковым содержимым

чтобы корректно Проверить наличие такого

объекта в массиве users можно

использовать метод сам внутри выполним

простую проверку на соответствие условию

р

name равно

Василий метод сам буквально проверяет

соответствует ли заданному условию хотя

бы один элемент массива и возвращает

True в случае успеха и false в ином и мы

видим в консоли True то есть в массиве

users Есть как минимум один объект у

которого значение свойства name Василий

А если нужно проверить Каждый элемент

массива на соответствие условию Допустим

мы хотим убедиться что все пользователи

в массиве users совершеннолетние что что

у них возраст больше 18ти для этого есть

метод Every метод проверяет что если при

переборе каждого элемента массива

callback вернул True то и результат

всего выражения результат всего э будет

также True если хотя бы один из

перебираемые не будет удовлетворять

условию H больше или равно

18 то в результате работы э вернёт false

А что если Мы просто хотим найти

конкретный элемент в массиве по условиям

для этого можно воспользоваться методом

find в консоли Мы видим что получили

элемент цельный Объект который был

найден по вот этим вот условием значение

свойства name равно строке Василий А что

будет если таких василиев в массиве

будет несколько метод find найдёт лишь

первый элемент удовлетворяющий условию в

callback функции Если же нам нужно найти

все элементы в массиве удовлетворяющее

условию Ну то есть произвести так

называемую фильтрацию массива то можно

воспользоваться методом фильтр меняем

find на фильтр и смотрим результат в

консоли мы видим массив с двумя

объектами в каждом из которых name - это

Василий метод фильтр очень полезный и

его используют в разработке довольно

часто его можно применять к абсолютно

любого формата массивом и в колке можно

проверить любые условия допустим Теперь

у юзеров в массиве users добавляется

город поле Сити наша абстрактная но

вполне допустимая в реальной практике

задача - получить отфильтрованный массив

в котором будут люди из Москвы или же

люди с возрастом до 45 лет для этого

достаточно написать такую

проверку применяем метод фильтр и

возвращаем подобный результат то есть мы

в функции колбеки вернули булевый

результат сравнени что User City равен

Москве или User Age меньше чем 45 вот

тут кстати деструктуризация полей Сити и

h из объекта US будет

нелишне так код будет Чите короче ну и

Давайте выведем Filter users в консоль в

результирующей массиве Filter users мы

получили то что хотели у каждого из этих

юзеров либо возраст менее 45 либо город

Москва А если бы метод фильтр не нашёл

бы ни одного элемента удовлетворяющего

условию то результатом был бы пустой

массив так как в массиве users нет

объектов у которых значение свойства H

больше

75 сдуй которые используются в

современной фронтенд разработке

постоянно метод Map этот метод позволяет

перебрать исходный массив И

преобразовать его модифицировать изменив

каждый из его элементов поработаем с тем

же массивом users который сейчас у нас

имеется как и в предыдущих методах

массива в аргумент передаётся функция

callback которая выполняется на каждой

итерации и предоставляет доступ к

параметрам Element Index и array к

текущему элементу индексу и самому

массиву

на каждой итерации цикла Map то есть в

теле этой callback функции должен

произойти возврат нового значения сейчас

мы выполнили Return Element без

изменений и в консоли в users formed мы

увидим точно такой же массив что и в

users Давайте превратим массив объектов

с данными о пользователях в массив

интересных строк во-первых второй и

третий параметр в этой callback функции

нам не нужны поэтому я их убираю а ещё

элемент Давайте переименую в User чтобы

было понятно с какой сущностью мы сейчас

работаем далее будем возвращать из

функции такую строку в обратных

кавычках смотрим в консоль массив users

formed теперь содержит вот такие вот

длинные строки то есть мы взяли и на

основе исходного массива users который

содержал объекты создали новый массив

используя информацию которая была в этих

объектах важно отметить что Map как и

остальные методы которые мы пока

рассматриваем не мутируют исходный

объект Что это значит если изменить Вот

эту вот инструкцию таким вот образом и

вывести в консоль

users то мы не увидим Никаких изменений

users Каким был таким и остался то есть

вот эта вот конструкция которую мы здесь

выполнили совершенно сейчас бесполезна

метод Map всегда возвращает новое

значение на основе массива к которому

его применили на основе его копии Ну а

так как мы это значение возвращаемое

методом Map никуда сейчас не присвоили

инструкция выполнила максимально впустую

А если мы всё же хотим мутировать то

есть изменить исходный массив исходную

переменную users то нужно сделать эту

переменную во-первых не константной то

есть объявить её допустим через ключевое

слово LED а затем буквально переп ей

новое значение в таком случае в users

будет обновлённый массив состоящий из

строк вместо объектов далее смотрим

самый сложный метод массивов с которым у

новичков частенько возникают трудности

метод Red сразу рассмотрим задачу У нас

есть всё тот же массив users Мы хотим

получить средний возраст всех

пользователей из этого массива Чтобы это

сделать нужно сначала просуммировать

значение H каждого из пользователей а

затем полученное число поделить на

количество пользователей в массиве users

всё это можно провернуть с помощью

классического цикла for нам понадобится

вспомогатель

которая будет хранить суммарный возраст

которая будет накапливать значени из

свойства H каждого из пользователей

Далее итери по users и плюсу в H

значение свойства H на каждом шаге цикла

в конце концов выводим в консоль

информацию

H делим на количество всех пользователей

то есть на длину массива users и

получаем средний возраст пользователей

из массива users

37 задачу можно гораздо изящнее решить

через метод Red метод rce Принимает два

аргумента callback функцию и через

запятую начальное значение в callback

функции есть аж четыре параметра первый

аккумулятор хранит результат предыдущего

вызова функции результат того что

вернули на предыдущей итерации цикла

если это первая итерация То есть первый

шаг цикла то сущность Амур изначально

будет содержать значение указанное во

втором аргументе Red число ноль в нашем

случае то есть это как бы начальное

значение нам аккуму нужен буквально для

хранения суммарного возраста всех

пользователей поэтому Можно

переименовать accumulator в

сам имя меняем Везде где сущность

accumulator была использована второй

параметр этой callback функции Element -

это текущий элемент массива Для более

читаемого кода также переименуй его

например на User

третий параметр Коб функции индекс

текущего элемента массива четвёртый

ссылка на сам перебираемые массив третий

и четвёртый параметры Нам сейчас не

понадобятся поэтому можно сразу их

убрать и увеличу масштаб Итак на каждой

итерации цикла Red в этой callback

функции Нужно вернуть новое значение то

есть выполнить так как мы собираем сумму

всех возрастов то нам нужно в значение

сум приплюсовать

сст из текущего объекта

перебираем инструкцию Return п

User так как для callback функции мы

использовали стрелочный синтаксис и у

нас всего лишь одна строка с то мы можем

даже написать всё это в одну строку вот

таким вот

образом и можно дополнительно из этой

сущности из этого объекта

деструктуризация

в этом месте получилась одна короткая

запись по итогу в переменной HS хранится

результат выполнения метода reduce у

users где на каждой итерации цикла в

callback функции Мы возвращаем новое

значение равная сумме всех предыдущих

значений и значение свойства h из

текущего объекта

перебирает понять что происходит на

каждой итерации цикла метода reduce

Давайте добавим перед этой инструкцией

ключевое слово

дебар и посмотрим на De Tools браузера с

помощью этого ключевого слова включается

специальный режим отладки кода и мы

можем исполнить его точечно по шагам Так

нам понадобится вытянуть Вот эту вот

часть и Давайте Уменьши

масштаб мы будем нажимать на вот эту вот

кнопку hk f9 по умолчанию и мы будем

наводить курсор на сущности в рамках

функции внутри и будем Какие в них

значения хранятся в момент выполнения

кода нажимаем вот эту кнопку несколько

раз и наводим на сум Def Tools нам

подсказывает что сейчас значение Ноль

это то самое значение которое мы указали

вред вторым аргументом если второй

аргумент в Red не

указать перезапуска и нажимаем f9 ещ

несколько раз смотрим в сам хранится на

первой итерации ссылка на Эмен перее

массива Это не то что мы хотим начальное

значение у нас будет но возвращаем как

было перезапуска жмём f9 Итак на Первом

шаге сам равен нулю а H равен

28 именно этот возраст у первого объекта

из массива users жмём f9 ещё несколько

раз чтобы выполнение кода перешло к

следующей итерации к снова наводим Наде

теперь в значении число 28 То есть то

что мы вернули на предыдущей итерации

цикла А в H теперь число 30 возраст у

второго юзера из массива users снова

жмём f9 несколько раз и на третьей

итерации цикла в сам уже число 58 А в

Age 40 это значение возраста у третьего

объекта из массива users В общем теперь

принцип метода Red должен быть понятен

на каждом шаге цикла мы используем

результат предыдущей итерации

метод Red по факту позволяет нам не

создавать никаких промежуточных

переменных вручную как это пришлось нам

делать при использовании цикла for с

помощью этого метода очень удобно

получать сумму каких-то значений из

каждого элемента массива Но на самом

деле мощь редьюс не ограничивается таким

простым сценарием метод редьюс по

умолчанию перебирает все элементы

массива слева направо Это и так очевидно

но мы можем дополнительно убедиться в

этом если в этом коде выведем до

выполнения этой инструкции

с в логах консоли мы видим H в таком

порядке 28 30 40 и 50 ровно в том

порядке в котором сейчас следуют объекты

в массиве users но иногда нам может

потребоваться перебрать элементы в

обратном порядке справа налево для этого

есть метод Red

Right делает абсолютно всё тоже самое но

перебирает элементы массива справа

налево и по консоли мы видим как порядок

выводимый сущностей H поменялся самый

сложный метод массивов позади осталось

рассмотреть всего парочку полезных

методов метод реверс просто

переворачивает исходный массив по

консоли мы можем увидеть вывод массива в

обратном порядке если в коде в массиве

users первым элементом идёт объект с

name алексанр то в консоли в результате

применения метода reverse первым уже

будет объект с Василий Однако важный

момент в отличие от всех рассмотренных

ранее методов массивов метод reverse

мутирует исходную сущность то есть

Несмотря на то что результат выполнения

выражения users reverse записан в

переменную revered users в исходной

переменной users также всё

поменялось по консоли мы видим как и

users и revered users хранят массивы в

идентично друг другу порядке Это очень

важный момент который важно помнить если

мы не хотим мутировать исходный массив

то мы можем перед вызовом метода reverse

сделать копию users таким образом

квадратные скобки три точки и название

копируемой сущности И теперь мы будем

переворачивать копию массива users по

консоли мы теперь видим что сущность

users осталась неизменной А в reversed

users хранится тот же самый массив но

уже в перевёрнутом порядке и Последний

Метод массивов на сегодня sort сортирует

исходный массив меняя порядок его

элементов как и предыдущий метод reverse

Метод sort мутирует исходный массив к

которому он был применён поэтому если мы

хотим работать над копией names можно

сделать так итак по консоли мы видим как

массив имён вывелся в алфавитном порядке

по возрастанию с массивами строк вроде

бы всё понятно но Давайте попробуем

отсортировать массив чисел по консоли мы

увидим что сортировка будет какой-то

странной числа не идут по порядку

возрастания Почему так JavaScript при

выполнении метода сор воспринимает

каждый из элементов массива как строку

то есть сравнивает элементы посимвольно

но мы можем на правила сортировки

поменять если укажем в аргументы сор

собственную колк функцию функция имеет

всего два параметра обычно их называют а

иб сравниваемые сущности на первой

итерации цикла в а будет значение 8 а в

число 4 на каждом шае цикла функция

должна вернуть одно из трёх значений

положительное число ноль или

отрицательное число если мы укажем в

качестве возвращаемого значения

выражения А - B то в случае когда

результат будет отрицательным числом

JavaScript сделает Вывод что А должно

идти раньше чем b если же результат

будет числом положительным то JavaScript

решит что в

сортирует раньше чем А ну а если в

результате этого выражения из кабк

функции вернётся число ноль то это будет

означать что оба значения А и B

эквивалентны и их порядок относительно

друг друга менять не нужно получается

что таким образом мы как бы добавили

собственную функцию сортировки и по

итогу в консоли мы видим корректный

порядок чисел 4 8 500 Если же мы хотим

получить сортировку не по возрастанию а

по убыванию то достаточно будет поменять

в этом выражении сущности А и B местами

B - А теперь рядок сортировки от

большего к

меньшему в этом уроке мы рассмотрели

принцип работы деструктуризация

для восприятия метод reduce и reduce

Right для перебора массива с накоплением

какого-то результата и в конце концов

мутируют массив методы реверс и сорт

предназначенный для переворачивания и

сортировки соответственно в следующем

уроке научимся удобно перебирать объекты

преобразовывать их по-всякому в массив и

обратно а также рассмотрим специальной

структуры данных коллекции Map и Set

подписывайтесь на канал чтобы не

пропустить новые материалы Спасибо за

просмотр и до встречи в следующих видео


